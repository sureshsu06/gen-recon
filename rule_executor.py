from typing import Dict, List, Any
import pandas as pd
from fuzzywuzzy import fuzz

class RuleExecutor:
    def execute(self, df1: pd.DataFrame, df2: pd.DataFrame, rules: Dict[str, Any]) -> Dict[str, List]:
        """Execute matching rules on the dataframes.
        
        Args:
            df1 (pd.DataFrame): Source dataframe
            df2 (pd.DataFrame): Target dataframe
            rules (dict): Rules generated by LLM analyzer
            
        Returns:
            dict: Results containing matched, pending_review, and unmatched items
        """
        results = {
            "matched": [],
            "pending_review": [],
            "unmatched_source": [],
            "unmatched_target": []
        }
        
        # Track which rows have been matched
        df1_matched = set()
        df2_matched = set()
        
        # Execute each rule
        for rule in rules["rules"]:
            if rule["type"] == "exact":
                matches = self._exact_match(
                    df1, df2,
                    rule["source_columns"],
                    rule["target_columns"],
                    df1_matched,
                    df2_matched
                )
                results["matched"].extend(matches)
            
            elif rule["type"] == "fuzzy":
                matches, pending = self._fuzzy_match(
                    df1, df2,
                    rule["source_columns"],
                    rule["target_columns"],
                    rule["options"].get("threshold", 0.8),
                    df1_matched,
                    df2_matched
                )
                results["matched"].extend(matches)
                results["pending_review"].extend(pending)
            
            elif rule["type"] == "amount":
                matches, pending = self._amount_match(
                    df1, df2,
                    rule["source_columns"],
                    rule["target_columns"],
                    rule["options"].get("tolerance", 0.01),
                    df1_matched,
                    df2_matched
                )
                results["matched"].extend(matches)
                results["pending_review"].extend(pending)
        
        # Add unmatched items
        for idx in range(len(df1)):
            if idx not in df1_matched:
                results["unmatched_source"].append(df1.iloc[idx].to_dict())
        
        for idx in range(len(df2)):
            if idx not in df2_matched:
                results["unmatched_target"].append(df2.iloc[idx].to_dict())
        
        return results
    
    def _exact_match(
        self,
        df1: pd.DataFrame,
        df2: pd.DataFrame,
        source_cols: List[str],
        target_cols: List[str],
        df1_matched: set,
        df2_matched: set
    ) -> List[Dict]:
        """Perform exact matching on specified columns.
        
        Args:
            df1 (pd.DataFrame): Source dataframe
            df2 (pd.DataFrame): Target dataframe
            source_cols (List[str]): Source columns to match
            target_cols (List[str]): Target columns to match
            df1_matched (set): Set of matched source indices
            df2_matched (set): Set of matched target indices
            
        Returns:
            List[Dict]: List of matched items
        """
        matches = []
        
        # Create keys from specified columns
        df1['_key'] = df1[source_cols].astype(str).agg('-'.join, axis=1)
        df2['_key'] = df2[target_cols].astype(str).agg('-'.join, axis=1)
        
        # Find matches
        for i, row1 in df1.iterrows():
            if i in df1_matched:
                continue
                
            for j, row2 in df2.iterrows():
                if j in df2_matched:
                    continue
                    
                if row1['_key'] == row2['_key']:
                    matches.append({
                        'source_index': i,
                        'target_index': j,
                        'source_data': row1.drop('_key').to_dict(),
                        'target_data': row2.drop('_key').to_dict()
                    })
                    df1_matched.add(i)
                    df2_matched.add(j)
                    break
        
        return matches
    
    def _fuzzy_match(
        self,
        df1: pd.DataFrame,
        df2: pd.DataFrame,
        source_cols: List[str],
        target_cols: List[str],
        threshold: float,
        df1_matched: set,
        df2_matched: set
    ) -> (List[Dict], List[Dict]):
        """Perform fuzzy matching on specified columns.
        
        Args:
            df1 (pd.DataFrame): Source dataframe
            df2 (pd.DataFrame): Target dataframe
            source_cols (List[str]): Source columns to match
            target_cols (List[str]): Target columns to match
            threshold (float): Similarity threshold (0-1)
            df1_matched (set): Set of matched source indices
            df2_matched (set): Set of matched target indices
            
        Returns:
            List[Dict]: List of matched items
        """
        matches = []
        pending_review = []
        
        for i, row1 in df1.iterrows():
            if i in df1_matched:
                continue
                
            source_text = ' '.join(str(row1[col]) for col in source_cols)
            best_match = None
            best_score = 0
            
            for j, row2 in df2.iterrows():
                if j in df2_matched:
                    continue
                    
                target_text = ' '.join(str(row2[col]) for col in target_cols)
                score = fuzz.ratio(source_text, target_text) / 100
                
                if score > best_score:
                    best_score = score
                    best_match = (j, row2)
            
            if best_score >= threshold and best_match:
                j, row2 = best_match
                match_obj = {
                    'source_index': i,
                    'target_index': j,
                    'similarity': best_score,
                    'source_data': row1.to_dict(),
                    'target_data': row2.to_dict()
                }
                if best_score < 0.95:
                    match_obj['explanation'] = f"Fuzzy match with similarity {best_score:.2f}, pending review."
                    pending_review.append(match_obj)
                else:
                    matches.append(match_obj)
                df1_matched.add(i)
                df2_matched.add(j)
        
        return matches, pending_review
    
    def _amount_match(
        self,
        df1: pd.DataFrame,
        df2: pd.DataFrame,
        source_cols: List[str],
        target_cols: List[str],
        tolerance: float,
        df1_matched: set,
        df2_matched: set
    ) -> (List[Dict], List[Dict]):
        """Perform amount matching with tolerance.
        
        Args:
            df1 (pd.DataFrame): Source dataframe
            df2 (pd.DataFrame): Target dataframe
            source_cols (List[str]): Source amount columns
            target_cols (List[str]): Target amount columns
            tolerance (float): Amount tolerance
            df1_matched (set): Set of matched source indices
            df2_matched (set): Set of matched target indices
            
        Returns:
            List[Dict]: List of matched items
        """
        matches = []
        pending_review = []
        
        for i, row1 in df1.iterrows():
            if i in df1_matched:
                continue
                
            source_amount = sum(float(row1[col]) for col in source_cols)
            
            for j, row2 in df2.iterrows():
                if j in df2_matched:
                    continue
                    
                target_amount = sum(float(row2[col]) for col in target_cols)
                
                diff = abs(source_amount - target_amount)
                
                if diff <= tolerance:
                    match_obj = {
                        'source_index': i,
                        'target_index': j,
                        'source_amount': source_amount,
                        'target_amount': target_amount,
                        'difference': source_amount - target_amount,
                        'source_data': row1.to_dict(),
                        'target_data': row2.to_dict()
                    }
                    if diff > 0.01:
                        match_obj['explanation'] = f"Amount match within loose tolerance ({diff:.2f}), pending review."
                        pending_review.append(match_obj)
                    else:
                        matches.append(match_obj)
                    df1_matched.add(i)
                    df2_matched.add(j)
                    break
        
        return matches, pending_review 